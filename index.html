<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="robots" content="noindex, nofollow">
    <title>MSTE v5.9 - Sea of Stars</title>
    
    <script src="stages.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #222; touch-action: none; user-select: none; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: 'Courier New', monospace; }
        canvas { display: block; box-shadow: 0 0 20px rgba(0, 255, 0, 0.2); background-color: #000; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        
        #message-box {
            text-align: center; color: #0f0; text-shadow: 0 0 10px #000; pointer-events: auto; cursor: pointer;
        }
        h1 { font-size: 40px; margin-bottom: 20px; text-shadow: 0 0 20px #0f0; }
        p { font-size: 20px; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0; } }

        #highscore-input {
            background: rgba(0, 0, 0, 0.9); border: 2px solid #0f0; padding: 20px; text-align: center; pointer-events: auto;
            box-shadow: 0 0 20px #0f0; z-index: 10;
        }
        #initials {
            background: #000; border: none; border-bottom: 2px solid #fff; 
            color: #fff; font-family: 'Courier New', monospace; font-size: 30px; 
            text-align: center; width: 100px; text-transform: uppercase; outline: none;
        }
        #submit-btn {
            display: block; margin: 20px auto 0; padding: 10px 20px; 
            background: #0f0; color: #000; border: none; font-weight: bold; font-size: 18px; cursor: pointer;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="message-box">
        <h1 id="main-title">MATH SAVE THE EARTH</h1>
        <p id="sub-text">[ CLICK TO START ]</p>
    </div>

    <div id="highscore-input" class="hidden">
        <h2 style="color:#ff0; margin-top:0;">NEW GLOBAL RECORD!</h2>
        <p style="color:#fff;">ENTER INITIALS:</p>
        <input type="text" id="initials" maxlength="3" autocomplete="off">
        <button id="submit-btn">UPLOAD</button>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * [LOGAN'S PATCH NOTE v5.9]
 * - Visual Upgrade: "Sea of Stars" Background.
 * - Parallax Effect: 3 layers of stars moving at different speeds.
 * - Continuous Rendering: Stars keep moving even when game is paused/over.
 */

// ★ YOUR SERVER URL (Keep this!) ★
const SERVER_URL = "https://script.google.com/macros/s/AKfycbyuDE-Zr7x7MdQu-Zj_hO3bl844y4YH7MguctqNkG5nzmGfdF8GtFNTMupG0Tfdm9m-/exec";

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const messageBox = document.getElementById('message-box');
const mainTitle = document.getElementById('main-title');
const subText = document.getElementById('sub-text');
const highscoreInput = document.getElementById('highscore-input');
const initialsField = document.getElementById('initials');
const submitBtn = document.getElementById('submit-btn');

const GAME_WIDTH = 600;
const GAME_HEIGHT = 1000;
let scale = 1, canvasOffsetX = 0, canvasOffsetY = 0;

let gameState = 'START'; 
let isDragging = false;
let lastTime = 0, elapsedTime = 0;
let stageClearTimer = 0;
let crashTimer = 0; 

const TIME_SCALE = 0.5; 
const ENEMY_BASE_SPEED = 100;
const CHAIN_DMG_DURATION = 0.65; 
const SPAWN_RATE_NUM = 750; 
const SPAWN_RATE_SYM = 1500; 
const COL_WIDTH = 60;
const ROW_TIME = 450; 
const START_DELAY = 2000; 
const ENEMY_WIDTH = 60;
const ENEMY_HEIGHT = 45;

let score = 0;
let currentLevel = 1;
let lives = 3;

// --- STAR BACKGROUND SYSTEM ---
const stars = [];
const STAR_COUNT = 100;

function initStars() {
    for (let i = 0; i < STAR_COUNT; i++) {
        stars.push({
            x: Math.random() * GAME_WIDTH,
            y: Math.random() * GAME_HEIGHT,
            size: Math.random() * 1.5 + 0.5, // 0.5 ~ 2.0
            speed: Math.random() * 50 + 20,  // 20 ~ 70 (Parallax speed)
            alpha: Math.random() * 0.5 + 0.3 // Opacity
        });
    }
}

function updateStars(dt) {
    stars.forEach(star => {
        star.y += star.speed * dt; // Move down
        if (star.y > GAME_HEIGHT) {
            star.y = 0; // Reset to top
            star.x = Math.random() * GAME_WIDTH; // Randomize X again
        }
    });
}

function drawStars() {
    ctx.save();
    stars.forEach(star => {
        ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        ctx.fill();
    });
    ctx.restore();
}

// Initialize Stars Immediately
initStars();


// --- GLOBAL SERVER LOGIC ---
let globalScores = [];
let isFetching = false;

function fetchGlobalScores() {
    isFetching = true;
    fetch(SERVER_URL)
        .then(response => response.json())
        .then(data => {
            if (Array.isArray(data)) globalScores = data;
            isFetching = false;
        })
        .catch(error => { console.error(error); isFetching = false; });
}

function sendGlobalScore(name, finalScore) {
    gameState = 'UPLOADING';
    highscoreInput.classList.add('hidden');
    fetch(SERVER_URL, {
        method: 'POST',
        body: JSON.stringify({ name: name, score: finalScore })
    })
    .then(response => response.json())
    .then(result => { fetchGlobalScores(); setTimeout(showLeaderboard, 1000); })
    .catch(error => { console.error(error); setTimeout(showLeaderboard, 1000); });
}

function checkIsHighScore(finalScore) {
    if (globalScores.length < 20) return true;
    return finalScore > globalScores[globalScores.length - 1].score;
}

fetchGlobalScores();

// --- GAME OBJECTS ---
const player = { x: GAME_WIDTH / 2, y: GAME_HEIGHT - 150, width: 40, height: 40, expr: "" };
let bullets = [], enemies = [], items = [], particles = [];
let enemySpawnData = [];
let lastSpawnNum = 0, lastSpawnSym = 0, numCounter = 1;

// --- INITIALIZATION ---
function resize() {
    const winW = window.innerWidth, winH = window.innerHeight;
    scale = Math.min(winW / GAME_WIDTH, winH / GAME_HEIGHT);
    canvas.style.width = `${GAME_WIDTH * scale}px`; canvas.style.height = `${GAME_HEIGHT * scale}px`;
    canvas.width = GAME_WIDTH; canvas.height = GAME_HEIGHT;
    canvasOffsetX = (winW - GAME_WIDTH * scale) / 2; canvasOffsetY = (winH - GAME_HEIGHT * scale) / 2;
}
window.addEventListener('resize', resize); resize();

function getGameCoordinates(clientX, clientY) {
    return { x: (clientX - canvasOffsetX) / scale, y: (clientY - canvasOffsetY) / scale };
}

// UI Handlers
messageBox.addEventListener('mousedown', handleUiClick);
messageBox.addEventListener('touchstart', (e) => { e.preventDefault(); handleUiClick(); });

function handleUiClick() {
    if (gameState === 'START' || gameState === 'LEADERBOARD') {
        startGame();
    } else if (gameState === 'TRANSITION') {
        resetStage();
    }
}

submitBtn.addEventListener('click', submitHighScore);
initialsField.addEventListener('keypress', function (e) {
    if (e.key === 'Enter') submitHighScore();
});

function submitHighScore() {
    const name = initialsField.value.toUpperCase().substring(0, 3) || "UNK";
    sendGlobalScore(name, score);
}

// --- LEVEL INTERPRETER ---
function generateLevel(levelNum) {
    let spawnList = [];
    if (typeof STAGE_DATA === 'undefined') return [];
    const stageConfig = STAGE_DATA[levelNum - 1];
    if (!stageConfig) return []; 

    if (stageConfig.spawnList) {
        stageConfig.spawnList.forEach(unit => {
            const pixelX = (unit.col - 1) * COL_WIDTH + (COL_WIDTH / 2);
            const spawnTime = (unit.row - 1) * ROW_TIME + START_DELAY;
            spawnList.push({ time: spawnTime, x: pixelX, hp: unit.hp, isBoss: unit.isBoss || false });
        });
    }
    spawnList.sort((a, b) => a.time - b.time);
    return spawnList;
}

// --- GAME FLOW ---
function startGame() { score = 0; currentLevel = 1; lives = 3; resetStage(); }

function resetStage() {
    gameState = 'PLAY';
    messageBox.classList.add('hidden');
    highscoreInput.classList.add('hidden');
    document.body.style.cursor = 'none';
    
    elapsedTime = 0; stageClearTimer = 0; crashTimer = 0;
    player.expr = "";
    bullets.length = 0; enemies.length = 0; items.length = 0; particles.length = 0;
    
    enemySpawnData = generateLevel(currentLevel);
    lastTime = performance.now();
    isDragging = true; 
    requestAnimationFrame(gameLoop);
}

function showLevelClearScreen() {
    gameState = 'TRANSITION';
    currentLevel++;
    messageBox.classList.remove('hidden');
    mainTitle.innerText = "STAGE CLEAR!";
    subText.innerText = `[ CLICK FOR LEVEL ${currentLevel} ]`; 
    subText.style.color = '#fff';
}

function triggerStageFail() {
    gameState = 'FAIL';
    messageBox.classList.remove('hidden');
    mainTitle.innerText = "DEFENSE FAILED!";
    subText.innerText = "RESTARTING STAGE..."; subText.style.color = '#f50';
    setTimeout(() => { resetStage(); }, 2000);
}

function handlePlayerCrash() {
    gameState = 'CRASHED';
    crashTimer = 0;
    isDragging = false;
    document.body.style.cursor = 'default';
    spawnExplosion(player.x, player.y - 20, 'critical', "SYSTEM FAILURE", 0, 1);
    for(let i=0; i<30; i++) {
        const ang = Math.random() * Math.PI * 2;
        const speed = Math.random() * 500 + 200;
        particles.push({ type:'spark', x: player.x, y: player.y - 20, vx: Math.cos(ang) * speed, vy: Math.sin(ang) * speed, size: Math.random() * 5 + 3, color: '#00ffff', life: 1.5, decay: 1.0 });
    }
}

function gameOver() {
    document.body.style.cursor = 'default';
    fetchGlobalScores();
    if (checkIsHighScore(score)) {
        gameState = 'INPUT';
        messageBox.classList.add('hidden');
        highscoreInput.classList.remove('hidden');
        initialsField.value = "";
        initialsField.focus();
    } else {
        showLeaderboard();
    }
}

function showLeaderboard() {
    gameState = 'LEADERBOARD';
    messageBox.classList.add('hidden');
    highscoreInput.classList.add('hidden');
}

// --- INPUT & UPDATE ---
window.addEventListener('mousedown', () => { if (gameState === 'LEADERBOARD') startGame(); else if (gameState === 'PLAY') isDragging = true; });
window.addEventListener('touchstart', (e) => { if (gameState === 'LEADERBOARD') { e.preventDefault(); startGame(); } else if (gameState === 'PLAY') { e.preventDefault(); isDragging = true; } }, { passive: false });
window.addEventListener('mouseup', () => { if(gameState==='PLAY' && isDragging) { isDragging = false; fireBullet(); }});
window.addEventListener('touchend', () => { if(gameState==='PLAY' && isDragging) { isDragging = false; fireBullet(); }});
window.addEventListener('mousemove', e => updatePlayerPos(e.clientX, e.clientY));
window.addEventListener('touchmove', e => { e.preventDefault(); updatePlayerPos(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });

function updatePlayerPos(clientX, clientY) {
    if (gameState !== 'PLAY' || !isDragging) return;
    const pos = getGameCoordinates(clientX, clientY);
    player.x = Math.max(30, Math.min(GAME_WIDTH - 30, pos.x));
    player.y = Math.max(50, Math.min(GAME_HEIGHT - 50, pos.y - 80));
}

function updateExpression(value) {
    const isNum = !isNaN(value); const strVal = String(value);
    let tokens = player.expr.match(/\d+|[+\-×÷]/g);
    if (!tokens) { if (isNum) player.expr = strVal; return; }
    let lastIsNum = !isNaN(tokens[tokens.length - 1]);
    if (isNum) { if (lastIsNum) tokens[tokens.length - 1] = strVal; else tokens.push(strVal); } 
    else { if (!lastIsNum) tokens[tokens.length - 1] = strVal; else tokens.push(strVal); }
    player.expr = tokens.join('');
}
function fireBullet() {
    if (player.expr === "") return;
    if (isNaN(player.expr[player.expr.length - 1])) player.expr = player.expr.slice(0, -1);
    if (player.expr === "") return;
    bullets.push({ x: player.x, y: player.y - 40, text: player.expr, speed: 800 });
    player.expr = "";
}

function spawnExplosion(x, y, tier, textValue, damageVal, multiplier) {
    let finalText = textValue;
    if (textValue !== "SYSTEM FAILURE" && tier === 'critical' && multiplier > 1) { finalText = `x${multiplier}!`; }
    let textColor = (textValue === "SYSTEM FAILURE") ? '#0ff' : ((tier === 'critical') ? '#ff0000' : '#ffffff');
    particles.push({ type: 'text', x, y, text: finalText, life: 1.0, vy: -150, isCritical: (tier === 'critical'), color: textColor });
    let count, speed, colors, shockSize;
    if (textValue === "SYSTEM FAILURE") { count=50; speed=800; colors=['#00ffff', '#ffffff', '#0088ff']; shockSize=500; } 
    else if(tier==='small') { count=8; speed=300; colors=['#ffff00']; } 
    else if(tier==='medium') { count=20; speed=500; colors=['#ff8800','#ff0000']; shockSize=100; } 
    else { count=40; speed=800; colors=['#ff0000','#ffffff']; shockSize=300; } 
    for(let i=0; i<count; i++){
        const ang = Math.random()*Math.PI*2, s = Math.random()*speed;
        particles.push({ type:'spark', x, y, vx:Math.cos(ang)*s, vy:Math.sin(ang)*s, size:Math.random()*4+2, color:colors[i%colors.length], life:1.0, decay:1.5 });
    }
    if(tier==='critical' || textValue === "SYSTEM FAILURE") { particles.push({ type:'shockwave', x, y, size:10, maxSize:shockSize, color:colors[0], life:1.0, decay:1.0, damage: damageVal, hitList: [], age: 0, multiplier: multiplier }); } 
    else if (tier==='medium') { particles.push({ type:'shockwave_visual', x, y, size:10, maxSize:shockSize, color:colors[0], life:1.0, decay:2.0 }); }
}

function update(dt) {
    // [UPDATE STARS ALWAYS] for atmosphere
    updateStars(dt);

    if (gameState === 'CRASHED') {
        crashTimer += dt;
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i]; p.life -= (p.decay || 1.0) * dt;
            if (p.type === 'text') p.y += p.vy * dt;
            else if (p.type === 'spark') { p.x += p.vx * dt; p.y += p.vy * dt; p.vx *= 0.9; p.vy *= 0.9; }
            else if (p.type === 'shockwave') { p.size += (p.maxSize - p.size) * 5 * dt; }
            if (p.life <= 0) particles.splice(i, 1);
        }
        if (crashTimer > 1.5) { lives--; if (lives <= 0) gameOver(); else triggerStageFail(); }
        return; 
    }

    if (gameState !== 'PLAY') return;
    elapsedTime += dt * 1000;

    if (enemySpawnData.length === 0 && enemies.length === 0) {
        stageClearTimer += dt; if (stageClearTimer > 3.0) showLevelClearScreen();
    }

    for (let i = enemySpawnData.length - 1; i >= 0; i--) {
        let data = enemySpawnData[i];
        if (elapsedTime >= data.time) {
            let width, height, speed, color, isBoss;
            if (data.isBoss) { width = 150; height = 100; speed = ENEMY_BASE_SPEED * 0.3; color = '#ff0000'; isBoss = true; } 
            else { width = ENEMY_WIDTH; height = ENEMY_HEIGHT; speed = ENEMY_BASE_SPEED; color = '#fff'; isBoss = false; }
            const drawX = data.x - (width / 2);
            enemies.push({ x: drawX, y: -80, width, height, hp: data.hp, maxHp: data.hp, speed, color, isBoss });
            enemySpawnData.splice(i, 1);
        }
    }
    
    lastSpawnNum += dt * 1000; lastSpawnSym += dt * 1000;
    if (enemies.length > 0 || enemySpawnData.length > 0) {
        if (lastSpawnNum > SPAWN_RATE_NUM) { items.push({ type:'num', val:numCounter, x:Math.random()*(GAME_WIDTH-60)+30, y:-40, speed:180 + Math.random()*60 }); numCounter=(numCounter%10)+1; lastSpawnNum = 0; }
        if (lastSpawnSym > SPAWN_RATE_SYM) { items.push({ type:'sym', val:['+','+','-','×','÷'][Math.floor(Math.random()*5)], x:Math.random()*(GAME_WIDTH-60)+30, y:-40, speed:120 + Math.random()*60 }); lastSpawnSym = 0; }
    }

    for (let i = items.length - 1; i >= 0; i--) {
        let it = items[i]; it.y += it.speed * dt;
        if (isDragging && Math.abs(it.x - player.x) < 40 && Math.abs(it.y - player.y) < 40) {
            if (!(player.expr === "" && it.type === 'sym')) { updateExpression(it.val); items.splice(i, 1); continue; }
        }
        if (it.y > GAME_HEIGHT) items.splice(i, 1);
    }

    for (let i = enemies.length - 1; i >= 0; i--) {
        let en = enemies[i]; en.y += en.speed * dt;
        if (Math.abs((en.x + en.width/2) - player.x) < (en.width/2 + 20) && Math.abs((en.y + en.height/2) - (player.y - 20)) < (en.height/2 + 20)) {
            handlePlayerCrash(); return;
        }
        if (en.y > GAME_HEIGHT) { lives--; if (lives <= 0) { gameOver(); } else { triggerStageFail(); } return; }
    }

    for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i]; b.y -= b.speed * dt;
        for (let j = enemies.length - 1; j >= 0; j--) {
            let en = enemies[j];
            if (b.x > en.x && b.x < en.x + en.width && b.y > en.y && b.y < en.y + en.height) {
                let cleanExpr = b.text.replace(/×/g, '*').replace(/÷/g, '/');
                let dmg = 1; try { dmg = Math.floor(eval(cleanExpr)); } catch(e) {}
                if (dmg < 1) dmg = 1;
                let isCrit = (en.hp === dmg);
                let tier = (en.hp - dmg <= 0) ? (isCrit ? 'critical' : 'medium') : 'small';
                let actualDmg = Math.min(en.hp, dmg);
                score += actualDmg;
                spawnExplosion(en.x + en.width/2, en.y + en.height/2, tier, isCrit ? "CRITICAL!" : dmg, dmg, 2);
                en.hp -= dmg;
                if (en.hp <= 0) enemies.splice(j, 1);
                bullets.splice(i, 1); 
                break;
            }
        }
        if (b.y < -100) bullets.splice(i, 1);
    }

    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i]; p.life -= (p.decay || 1.0) * dt;
        p.y += ENEMY_BASE_SPEED * dt; 
        if (p.type === 'text') p.y += p.vy * dt;
        else if (p.type === 'spark') { p.x += p.vx * dt; p.y += p.vy * dt; p.vx *= 0.9; p.vy *= 0.9; p.vy += 10; }
        else if (p.type === 'shockwave' || p.type === 'shockwave_visual') {
            p.size += (p.maxSize - p.size) * 3 * dt; 
            if (p.type === 'shockwave') {
                p.age += dt;
                if (p.age <= CHAIN_DMG_DURATION) {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        let en = enemies[j];
                        if (en.y < 0 || en.y > GAME_HEIGHT) continue;
                        if (p.hitList.includes(en)) continue;
                        let dist = Math.hypot((en.x + en.width/2) - p.x, (en.y + en.height/2) - p.y);
                        if (dist < p.size - 10) {
                            let isStrictCrit = (en.hp === p.damage); 
                            let actualDmg = Math.min(en.hp, p.damage);
                            score += actualDmg * p.multiplier;
                            en.hp -= p.damage;
                            p.hitList.push(en); 
                            if (en.hp <= 0) {
                                if (isStrictCrit) spawnExplosion(en.x + en.width/2, en.y + en.height/2, 'critical', "CHAIN!", p.damage, p.multiplier + 1);
                                else spawnExplosion(en.x + en.width/2, en.y + en.height/2, 'medium', p.damage, 1);
                                enemies.splice(j, 1);
                            } else { spawnExplosion(en.x + en.width/2, en.y + en.height/2, 'small', p.damage, 1); }
                        }
                    }
                }
            }
        }
        if (p.life <= 0) particles.splice(i, 1);
    }
}

function draw() {
    ctx.fillStyle = '#000'; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    
    // [DRAW STARS FIRST]
    drawStars();

    ctx.strokeStyle = '#333'; ctx.lineWidth = 2; ctx.strokeRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    if (gameState === 'LEADERBOARD' || gameState === 'UPLOADING') {
        ctx.save();
        ctx.fillStyle = '#0f0'; ctx.font = 'bold 40px Courier New'; ctx.textAlign = 'center';
        ctx.fillText("GLOBAL RANKING", GAME_WIDTH/2, 100);
        ctx.fillStyle = '#fff'; ctx.font = '24px Courier New';
        ctx.fillText(`YOUR SCORE: ${score}`, GAME_WIDTH/2, 150);

        if (gameState === 'UPLOADING') {
            ctx.fillStyle = '#ff0'; ctx.font = '30px Courier New';
            ctx.fillText("UPLOADING TO SERVER...", GAME_WIDTH/2, GAME_HEIGHT/2);
        } else if (isFetching) {
            ctx.fillStyle = '#ff0'; ctx.font = '30px Courier New';
            ctx.fillText("FETCHING DATA...", GAME_WIDTH/2, GAME_HEIGHT/2);
        } else {
            ctx.textAlign = 'left';
            let startY = 220;
            globalScores.forEach((entry, idx) => {
                if (idx >= 20) return;
                let rank = (idx + 1) + ".";
                let color = (entry.score === score && entry.name === initialsField.value) ? '#ff0' : '#fff';
                ctx.fillStyle = color;
                ctx.fillText(rank.padEnd(4) + String(entry.name).padEnd(5) + String(entry.score).padStart(8), 150, startY + (idx * 35));
            });
            if (Math.floor(Date.now() / 500) % 2 === 0) {
                ctx.fillStyle = '#f00'; ctx.textAlign = 'center';
                ctx.fillText("[ CLICK TO RESTART ]", GAME_WIDTH/2, GAME_HEIGHT - 50);
            }
        }
        ctx.restore();
        return;
    }

    if (gameState === 'PLAY' || gameState === 'TRANSITION' || gameState === 'FAIL' || gameState === 'INPUT' || gameState === 'CRASHED') {
        ctx.save();
        if (gameState === 'INPUT' || gameState === 'CRASHED') ctx.globalAlpha = (gameState === 'CRASHED' ? 1.0 : 0.3);

        ctx.fillStyle = '#fff'; ctx.font = 'bold 24px Courier New';
        ctx.textAlign = 'left'; ctx.fillText(`LV: ${currentLevel}`, 20, 30);
        ctx.textAlign = 'center'; ctx.fillText(`SCORE: ${score}`, GAME_WIDTH / 2, 30);
        ctx.textAlign = 'right'; ctx.fillStyle = '#f00';
        let hearts = "♥".repeat(Math.max(0, lives)); ctx.fillText(`LIVES: ${hearts}`, GAME_WIDTH - 20, 30);

        items.forEach(it => { ctx.fillStyle = (it.type==='num'?'#ff0':'#0f0'); ctx.font = 'bold 24px Courier New'; ctx.textAlign = 'center'; ctx.fillText(it.val, it.x, it.y); });
        
        enemies.forEach(en => { 
            ctx.strokeStyle = en.color; ctx.lineWidth = en.isBoss ? 4 : 2; ctx.strokeRect(en.x, en.y, en.width, en.height); 
            ctx.fillStyle = '#fff'; ctx.font = '30px Courier New'; ctx.textAlign = 'center'; ctx.textBaseline='middle'; 
            ctx.fillText(en.hp > 0 ? en.hp : "", en.x + en.width/2, en.y + en.height/2); 
            if (en.isBoss) {
                ctx.fillStyle = '#333'; ctx.fillRect(en.x, en.y - 15, en.width, 10);
                ctx.fillStyle = '#f00'; let hpPercent = en.hp / en.maxHp; ctx.fillRect(en.x, en.y - 15, en.width * hpPercent, 10);
            }
        });
        
        bullets.forEach(b => { ctx.save(); ctx.translate(b.x, b.y); ctx.rotate(Math.PI/2); ctx.fillStyle = '#aaf'; ctx.font = '20px Courier New'; ctx.textAlign = 'center'; ctx.fillText(b.text, 0, 0); ctx.restore(); });
        
        if (gameState !== 'CRASHED' && gameState !== 'FAIL' && gameState !== 'GAMEOVER') {
            if (player.expr !== "") {
                ctx.save(); ctx.font = 'bold 40px Courier New'; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
                ctx.shadowColor = '#0f0'; ctx.shadowBlur = 10; ctx.fillStyle = '#fff';
                ctx.fillText(player.expr, GAME_WIDTH / 2, GAME_HEIGHT - 20); ctx.restore();
            }
            ctx.save(); if (!isDragging && gameState === 'PLAY') ctx.globalAlpha = 0.3;
            ctx.translate(player.x, player.y); ctx.fillStyle = '#0ff';
            ctx.beginPath(); ctx.moveTo(0, -30); ctx.lineTo(-20, 20); ctx.lineTo(0, 10); ctx.lineTo(20, 20); ctx.closePath(); ctx.fill();
            ctx.restore();
        }

        particles.forEach(p => {
            ctx.save(); ctx.globalAlpha = p.life;
            if (p.type === 'text') { ctx.translate(p.x, p.y); ctx.fillStyle = p.color; ctx.font = (p.isCritical?'bold 40px':'30px') + ' Courier New'; ctx.textAlign = 'center'; ctx.fillText(p.text, 0, 0); }
            else if (p.type === 'spark') { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI*2); ctx.fill(); }
            else if (p.type === 'shockwave' || p.type === 'shockwave_visual') { ctx.strokeStyle = p.color; ctx.lineWidth = 5 * p.life; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.stroke(); }
            ctx.restore();
        });
        ctx.restore();
    }
}

function gameLoop(currentTime) {
    const dt = (currentTime - lastTime) / 1000;
    lastTime = currentTime;
    if (dt < 0.1) { update(dt * TIME_SCALE); } 
    draw(); 
    requestAnimationFrame(gameLoop);
}
</script>
</body>
</html>