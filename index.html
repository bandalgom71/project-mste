<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="robots" content="noindex, nofollow">
    <title>MSTE v4.3 - External Data Linked</title>
    
    <script src="stages.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #222; touch-action: none; user-select: none; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { display: block; box-shadow: 0 0 20px rgba(0, 255, 0, 0.2); background-color: #000; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        
        #message-box {
            text-align: center; color: #0f0; font-family: 'Courier New', monospace;
            text-shadow: 0 0 10px #000; pointer-events: auto; cursor: pointer;
        }
        h1 { font-size: 40px; margin-bottom: 20px; text-shadow: 0 0 20px #0f0; }
        p { font-size: 20px; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0; } }

        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="message-box">
        <h1 id="main-title">MATH SAVE THE EARTH</h1>
        <p id="sub-text">[ CLICK TO START ]</p>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * [LOGAN'S SYSTEM CORE v4.3]
 * - Architecture: Loads level data from external 'stages.js'.
 * - Mechanics: Chain reaction (strict), Combo multiplier, Effective score.
 * - Physics: Relative scrolling for particles.
 * - Flow: Restart stage on life loss, Game Over on 0 lives.
 */

// --- SECURITY CHECK ---
// 다른 사람이 접속했을 때 암호를 묻습니다. (테스트할 때 불편하면 주석 처리하세요)
const PASSCODE = "1234";
/*
let userPass = prompt("접속 암호를 입력하게, 요원.");
if (userPass !== PASSCODE) {
    alert("접근 거부.");
    document.body.innerHTML = "<h1 style='color:red; text-align:center; margin-top:50px;'>ACCESS DENIED</h1>";
    throw new Error("Wrong Password");
}
*/

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const messageBox = document.getElementById('message-box');
const mainTitle = document.getElementById('main-title');
const subText = document.getElementById('sub-text');

const GAME_WIDTH = 600;
const GAME_HEIGHT = 1000;
let scale = 1, canvasOffsetX = 0, canvasOffsetY = 0;

// Game State: START, PLAY, TRANSITION, FAIL, GAMEOVER
let gameState = 'START'; 
let isDragging = false;
let lastTime = 0, elapsedTime = 0;

const TIME_SCALE = 0.5; 
const ENEMY_BASE_SPEED = 100;
const HITBOX_REDUCTION = 20;
const CHAIN_DMG_DURATION = 0.65; 
const SPAWN_RATE_NUM = 750; 
const SPAWN_RATE_SYM = 1500; 

let score = 0;
let currentLevel = 1;
let lives = 3;

const player = { x: GAME_WIDTH / 2, y: GAME_HEIGHT - 150, width: 60, height: 60, expr: "" };
let bullets = [], enemies = [], items = [], particles = [];
let enemySpawnData = [];
let lastSpawnNum = 0, lastSpawnSym = 0, numCounter = 1;

// --- INITIALIZATION ---
function resize() {
    const winW = window.innerWidth, winH = window.innerHeight;
    scale = Math.min(winW / GAME_WIDTH, winH / GAME_HEIGHT);
    canvas.style.width = `${GAME_WIDTH * scale}px`; canvas.style.height = `${GAME_HEIGHT * scale}px`;
    canvas.width = GAME_WIDTH; canvas.height = GAME_HEIGHT;
    canvasOffsetX = (winW - GAME_WIDTH * scale) / 2; canvasOffsetY = (winH - GAME_HEIGHT * scale) / 2;
}
window.addEventListener('resize', resize); resize();

function getGameCoordinates(clientX, clientY) {
    return { x: (clientX - canvasOffsetX) / scale, y: (clientY - canvasOffsetY) / scale };
}

// UI Handler
messageBox.addEventListener('mousedown', handleUiClick);
messageBox.addEventListener('touchstart', (e) => { e.preventDefault(); handleUiClick(); });

function handleUiClick() {
    if (gameState === 'START' || gameState === 'GAMEOVER') {
        startGame();
    }
}

// --- NEW LEVEL GENERATOR (Interpreter) ---
function generateLevel(levelNum) {
    let spawnList = [];
    
    // Check if stages.js is loaded
    if (typeof STAGE_DATA === 'undefined') {
        alert("CRITICAL ERROR: 'stages.js' file not found!");
        return [];
    }

    // 1. Get Config from stages.js
    const stageConfig = STAGE_DATA[levelNum - 1];
    if (!stageConfig) return []; // No data = Game Clear

    // 2. Parse Waves
    stageConfig.waves.forEach(wave => {
        if (wave.type === 'pattern') {
            for (let t = wave.start; t < wave.end; t += wave.gap) {
                wave.formations.forEach((unit, idx) => {
                    spawnList.push({
                        time: t + (idx * 200),
                        x: unit.x,
                        hp: unit.hp
                    });
                });
            }
        }
        else if (wave.type === 'sine') {
            for (let t = wave.start; t < wave.end; t += wave.gap) {
                const normalizedTime = (t - wave.start) / 1000;
                const x = 300 + 200 * Math.sin(normalizedTime);
                spawnList.push({ time: t, x: x, hp: wave.hp });
            }
        }
        else if (wave.type === 'grid') {
            for (let t = wave.start; t < wave.end; t += wave.gap) {
                for (let col = 0; col < 5; col++) {
                    spawnList.push({ time: t, x: 80 + col * 110, hp: wave.hp });
                }
            }
        }
        else if (wave.type === 'boss') {
            spawnList.push({
                time: wave.time,
                x: wave.x,
                hp: wave.hp,
                isBoss: true
            });
        }
    });

    // 3. Sort by time
    spawnList.sort((a, b) => a.time - b.time);
    return spawnList;
}

// --- GAME FLOW CONTROL ---
function startGame() {
    score = 0; currentLevel = 1; lives = 3;
    resetStage();
}

function resetStage() {
    gameState = 'PLAY';
    messageBox.classList.add('hidden');
    document.body.style.cursor = 'none';
    
    elapsedTime = 0;
    player.expr = "";
    bullets.length = 0; enemies.length = 0; items.length = 0; particles.length = 0;
    
    // Load Data from JS file
    enemySpawnData = generateLevel(currentLevel);
    
    lastTime = performance.now();
    isDragging = true; 
    requestAnimationFrame(gameLoop);
}

function startLevelTransition() {
    gameState = 'TRANSITION';
    currentLevel++;
    messageBox.classList.remove('hidden');
    mainTitle.innerText = "STAGE CLEAR!";
    subText.innerText = `NEXT: LEVEL ${currentLevel}`;
    subText.style.color = '#fff';
    setTimeout(() => { resetStage(); }, 3000);
}

function triggerStageFail() {
    gameState = 'FAIL';
    messageBox.classList.remove('hidden');
    mainTitle.innerText = "DEFENSE FAILED!";
    subText.innerText = "RESTARTING STAGE...";
    subText.style.color = '#f50';
    setTimeout(() => { resetStage(); }, 2000);
}

function gameOver() {
    gameState = 'GAMEOVER';
    document.body.style.cursor = 'default';
    messageBox.classList.remove('hidden');
    mainTitle.innerText = "GAME OVER";
    subText.innerText = `SCORE: ${score}\n[ CLICK TO RETRY ]`;
    subText.style.color = '#f00';
}

// Input Handling
window.addEventListener('mousedown', () => { if(gameState==='PLAY') isDragging = true; });
window.addEventListener('mouseup', () => { if(gameState==='PLAY' && isDragging) { isDragging = false; fireBullet(); }});
window.addEventListener('touchstart', (e) => { e.preventDefault(); if(gameState==='PLAY') isDragging = true; }, { passive: false });
window.addEventListener('touchend', () => { if(gameState==='PLAY' && isDragging) { isDragging = false; fireBullet(); }});

function updatePlayerPos(clientX, clientY) {
    if (gameState !== 'PLAY' || !isDragging) return;
    const pos = getGameCoordinates(clientX, clientY);
    player.x = Math.max(30, Math.min(GAME_WIDTH - 30, pos.x));
    player.y = Math.max(50, Math.min(GAME_HEIGHT - 50, pos.y - 80));
}
window.addEventListener('mousemove', e => updatePlayerPos(e.clientX, e.clientY));
window.addEventListener('touchmove', e => { e.preventDefault(); updatePlayerPos(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });

// --- LOGIC ---
function updateExpression(value) {
    const isNum = !isNaN(value); const strVal = String(value);
    let tokens = player.expr.match(/\d+|[+\-×÷]/g);
    if (!tokens) { if (isNum) player.expr = strVal; return; }
    let lastIsNum = !isNaN(tokens[tokens.length - 1]);
    if (isNum) { if (lastIsNum) tokens[tokens.length - 1] = strVal; else tokens.push(strVal); } 
    else { if (!lastIsNum) tokens[tokens.length - 1] = strVal; else tokens.push(strVal); }
    player.expr = tokens.join('');
}
function fireBullet() {
    if (player.expr === "") return;
    if (isNaN(player.expr[player.expr.length - 1])) player.expr = player.expr.slice(0, -1);
    if (player.expr === "") return;
    bullets.push({ x: player.x, y: player.y - 40, text: player.expr, speed: 800 });
    player.expr = "";
}

function spawnExplosion(x, y, tier, textValue, damageVal, multiplier) {
    let finalText = textValue;
    if (tier === 'critical' && multiplier > 1) finalText = `x${multiplier}!`;
    particles.push({ type: 'text', x, y, text: finalText, life: 1.0, vy: -150, isCritical: (tier === 'critical'), color: (tier === 'critical') ? '#ff0000' : '#ffffff' });
    let count, speed, colors, shockSize;
    if(tier==='small') { count=8; speed=300; colors=['#ffff00']; }
    else if(tier==='medium') { count=20; speed=500; colors=['#ff8800','#ff0000']; shockSize=100; }
    else { count=40; speed=800; colors=['#ff0000','#ffffff']; shockSize=300; } 
    for(let i=0; i<count; i++){
        const ang = Math.random()*Math.PI*2, s = Math.random()*speed;
        particles.push({ type:'spark', x, y, vx:Math.cos(ang)*s, vy:Math.sin(ang)*s, size:Math.random()*4+2, color:colors[i%colors.length], life:1.0, decay:1.5 });
    }
    if(tier==='critical') {
        particles.push({ type:'shockwave', x, y, size:10, maxSize:shockSize, color:colors[0], life:1.0, decay:1.0, damage: damageVal, hitList: [], age: 0, multiplier: multiplier });
    } else if (tier==='medium') {
        particles.push({ type:'shockwave_visual', x, y, size:10, maxSize:shockSize, color:colors[0], life:1.0, decay:2.0 });
    }
}

// --- UPDATE LOOP ---
function update(dt) {
    if (gameState !== 'PLAY') return;
    elapsedTime += dt * 1000;
    
    // Level Clear Check
    if (enemySpawnData.length === 0 && enemies.length === 0) {
        startLevelTransition();
        return;
    }

    // Spawn Enemies
    for (let i = enemySpawnData.length - 1; i >= 0; i--) {
        let data = enemySpawnData[i];
        if (elapsedTime >= data.time) {
            let width, height, speed, color, isBoss;
            if (data.isBoss) {
                width = 150; height = 100; speed = ENEMY_BASE_SPEED * 0.3; color = '#ff0000'; isBoss = true;
            } else {
                width = 60 + (String(data.hp).length * 10); height = 60; speed = ENEMY_BASE_SPEED; color = '#fff'; isBoss = false;
            }
            const drawX = data.x - (width / 2);
            enemies.push({ x: drawX, y: -80, width, height, hp: data.hp, maxHp: data.hp, speed, color, isBoss });
            enemySpawnData.splice(i, 1);
        }
    }
    
    lastSpawnNum += dt * 1000; lastSpawnSym += dt * 1000;
    if (lastSpawnNum > SPAWN_RATE_NUM) { items.push({ type:'num', val:numCounter, x:Math.random()*(GAME_WIDTH-60)+30, y:-40, speed:180 + Math.random()*60 }); numCounter=(numCounter%10)+1; lastSpawnNum = 0; }
    if (lastSpawnSym > SPAWN_RATE_SYM) { items.push({ type:'sym', val:['+','+','-','×','÷'][Math.floor(Math.random()*5)], x:Math.random()*(GAME_WIDTH-60)+30, y:-40, speed:120 + Math.random()*60 }); lastSpawnSym = 0; }

    // Items
    for (let i = items.length - 1; i >= 0; i--) {
        let it = items[i]; it.y += it.speed * dt;
        if (isDragging && Math.abs(it.x - player.x) < 40 && Math.abs(it.y - player.y) < 40) {
            if (!(player.expr === "" && it.type === 'sym')) { updateExpression(it.val); items.splice(i, 1); continue; }
        }
        if (it.y > GAME_HEIGHT) items.splice(i, 1);
    }

    // Enemies & Lives
    for (let i = enemies.length - 1; i >= 0; i--) {
        let en = enemies[i]; en.y += en.speed * dt;
        if (en.y > GAME_HEIGHT) {
            lives--; 
            if (lives <= 0) { gameOver(); } else { triggerStageFail(); }
            return; 
        }
    }

    // Bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i]; b.y -= b.speed * dt;
        for (let j = enemies.length - 1; j >= 0; j--) {
            let en = enemies[j];
            if (b.x > en.x && b.x < en.x + en.width && b.y > en.y && b.y < en.y + en.height) {
                let cleanExpr = b.text.replace(/×/g, '*').replace(/÷/g, '/');
                let dmg = 1; try { dmg = Math.floor(eval(cleanExpr)); } catch(e) {}
                if (dmg < 1) dmg = 1;
                let isCrit = (en.hp === dmg);
                let tier = (en.hp - dmg <= 0) ? (isCrit ? 'critical' : 'medium') : 'small';
                let actualDmg = Math.min(en.hp, dmg);
                score += actualDmg; // Base multiplier 1
                spawnExplosion(en.x + en.width/2, en.y + en.height/2, tier, isCrit ? "CRITICAL!" : dmg, dmg, 2);
                en.hp -= dmg;
                if (en.hp <= 0) enemies.splice(j, 1);
                bullets.splice(i, 1); 
                break;
            }
        }
        if (b.y < -100) bullets.splice(i, 1);
    }

    // Particles (Relative Scroll)
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i]; p.life -= (p.decay || 1.0) * dt;
        p.y += ENEMY_BASE_SPEED * dt; // Scroll with world
        
        if (p.type === 'text') p.y += p.vy * dt;
        else if (p.type === 'spark') { p.x += p.vx * dt; p.y += p.vy * dt; p.vx *= 0.9; p.vy *= 0.9; p.vy += 10; }
        else if (p.type === 'shockwave' || p.type === 'shockwave_visual') {
            p.size += (p.maxSize - p.size) * 3 * dt; 
            if (p.type === 'shockwave') {
                p.age += dt;
                if (p.age <= CHAIN_DMG_DURATION) {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        let en = enemies[j];
                        if (en.y < 0 || en.y > GAME_HEIGHT) continue;
                        if (p.hitList.includes(en)) continue;
                        let dist = Math.hypot((en.x + en.width/2) - p.x, (en.y + en.height/2) - p.y);
                        if (dist < p.size - HITBOX_REDUCTION) {
                            let isStrictCrit = (en.hp === p.damage); 
                            let actualDmg = Math.min(en.hp, p.damage);
                            score += actualDmg * p.multiplier;
                            en.hp -= p.damage;
                            p.hitList.push(en); 
                            if (en.hp <= 0) {
                                if (isStrictCrit) spawnExplosion(en.x + en.width/2, en.y + en.height/2, 'critical', "CHAIN!", p.damage, p.multiplier + 1);
                                else spawnExplosion(en.x + en.width/2, en.y + en.height/2, 'medium', p.damage, 1);
                                enemies.splice(j, 1);
                            } else {
                                spawnExplosion(en.x + en.width/2, en.y + en.height/2, 'small', p.damage, 1);
                            }
                        }
                    }
                }
            }
        }
        if (p.life <= 0) particles.splice(i, 1);
    }
}

function draw() {
    ctx.fillStyle = '#000'; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    ctx.strokeStyle = '#333'; ctx.lineWidth = 2; ctx.strokeRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    if (gameState === 'PLAY' || gameState === 'TRANSITION' || gameState === 'FAIL') {
        // UI
        ctx.save();
        ctx.fillStyle = '#fff'; ctx.font = 'bold 24px Courier New';
        ctx.textAlign = 'left'; ctx.fillText(`LV: ${currentLevel}`, 20, 30);
        ctx.textAlign = 'center'; ctx.fillText(`SCORE: ${score}`, GAME_WIDTH / 2, 30);
        ctx.textAlign = 'right'; ctx.fillStyle = '#f00';
        let hearts = "♥".repeat(Math.max(0, lives)); ctx.fillText(`LIVES: ${hearts}`, GAME_WIDTH - 20, 30);
        ctx.restore();

        // Player
        if (player.expr !== "") {
            ctx.save(); ctx.font = 'bold 40px Courier New'; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
            ctx.shadowColor = '#0f0'; ctx.shadowBlur = 10; ctx.fillStyle = '#fff';
            ctx.fillText(player.expr, GAME_WIDTH / 2, GAME_HEIGHT - 20); ctx.restore();
        }
        ctx.save(); if (!isDragging && gameState === 'PLAY') ctx.globalAlpha = 0.3;
        ctx.translate(player.x, player.y); ctx.fillStyle = '#0ff';
        ctx.beginPath(); ctx.moveTo(0, -30); ctx.lineTo(-20, 20); ctx.lineTo(0, 10); ctx.lineTo(20, 20); ctx.closePath(); ctx.fill();
        ctx.restore();

        // Objects
        items.forEach(it => { ctx.fillStyle = (it.type==='num'?'#ff0':'#0f0'); ctx.font = 'bold 24px Courier New'; ctx.textAlign = 'center'; ctx.fillText(it.val, it.x, it.y); });
        
        enemies.forEach(en => { 
            ctx.strokeStyle = en.color; 
            ctx.lineWidth = en.isBoss ? 4 : 2; 
            ctx.strokeRect(en.x, en.y, en.width, en.height); 
            ctx.fillStyle = '#fff'; ctx.font = '30px Courier New'; ctx.textAlign = 'center'; ctx.textBaseline='middle'; 
            ctx.fillText(en.hp > 0 ? en.hp : "", en.x + en.width/2, en.y + en.height/2); 
            if (en.isBoss) {
                ctx.fillStyle = '#333'; ctx.fillRect(en.x, en.y - 15, en.width, 10);
                ctx.fillStyle = '#f00'; let hpPercent = en.hp / en.maxHp; ctx.fillRect(en.x, en.y - 15, en.width * hpPercent, 10);
            }
        });
        
        bullets.forEach(b => { ctx.save(); ctx.translate(b.x, b.y); ctx.rotate(Math.PI/2); ctx.fillStyle = '#aaf'; ctx.font = '20px Courier New'; ctx.textAlign = 'center'; ctx.fillText(b.text, 0, 0); ctx.restore(); });
        
        particles.forEach(p => {
            ctx.save(); ctx.globalAlpha = p.life;
            if (p.type === 'text') { ctx.translate(p.x, p.y); ctx.fillStyle = p.color; ctx.font = (p.isCritical?'bold 40px':'30px') + ' Courier New'; ctx.textAlign = 'center'; ctx.fillText(p.text, 0, 0); }
            else if (p.type === 'spark') { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI*2); ctx.fill(); }
            else if (p.type === 'shockwave' || p.type === 'shockwave_visual') { ctx.strokeStyle = p.color; ctx.lineWidth = 5 * p.life; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.stroke(); }
            ctx.restore();
        });
    }
}

function gameLoop(currentTime) {
    const dt = (currentTime - lastTime) / 1000;
    lastTime = currentTime;
    if (gameState === 'PLAY') { if (dt < 0.1) { update(dt * TIME_SCALE); } }
    draw(); 
    requestAnimationFrame(gameLoop);
}
</script>
</body>
</html>